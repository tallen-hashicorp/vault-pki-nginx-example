# vault-pki-nginx-example
An example of using Vault PKI with an NGINX server on a Linux server.

## Install NGINX
The following works on Ubuntu; however, you can easily use yum if you are working on RHEL or SUSE.

```bash
sudo apt-get install nginx jq
```

## Configure Vault
The following steps are taken directly from: [Build your own certificate authority (CA)](https://developer.hashicorp.com/vault/tutorials/secrets-management/pki-engine)

### Login
```bash
export VAULT_ADDR='http://127.0.0.1:8200'
vault login
```

### Create root CA
This will be used to sign the intermediate store. We will also use the `root_2023_ca.crt` later to add to the trust store.

```bash
vault secrets enable pki

vault secrets tune -max-lease-ttl=87600h pki

vault write -field=certificate pki/root/generate/internal \
     common_name="example.com" \
     issuer_name="root-2023" \
     ttl=87600h > root_2023_ca.crt

vault write pki/roles/2023-servers allow_any_name=true

vault write pki/config/urls \
     issuing_certificates="$VAULT_ADDR/v1/pki/ca" \
     crl_distribution_points="$VAULT_ADDR/v1/pki/crl"
```

### Generate intermediate CA
Now, you are going to create an intermediate CA using the root CA you regenerated in the above step.

```bash
vault secrets enable -path=pki_int pki

vault secrets tune -max-lease-ttl=43800h pki_int

vault write -format=json pki_int/intermediate/generate/internal \
     common_name="example.com Intermediate Authority" \
     issuer_name="example-dot-com-intermediate" \
     | jq -r '.data.csr' > pki_intermediate.csr

vault write -format=json pki/root/sign-intermediate \
     issuer_ref="root-2023" \
     csr=@pki_intermediate.csr \
     format=pem_bundle ttl="43800h" \
     | jq -r '.data.certificate' > intermediate.cert.pem

vault write pki_int/intermediate/set-signed certificate=@intermediate.cert.pem

vault write pki_int/roles/example-dot-com \
     issuer_ref="$(vault read -field=default pki_int/config/issuers)" \
     allowed_domains="example.com" \
     allow_subdomains=true \
     max_ttl="720h"
```

### Request certificates
This gets a cert we will use later in NGINX.

```bash
vault write -format=json pki_int/issue/example-dot-com common_name="test.example.com" ttl="24h" > nginx_certs.json
jq -r '.data.private_key' nginx_certs.json > nginx_private_key.pem
jq -r '.data.certificate' nginx_certs.json > nginx_certificate.pem
jq -r '.data.ca_chain[]' nginx_certs.json > nginx_ca_chain.pem
cat nginx_certificate.pem nginx_ca_chain.pem > nginx_certificate_chain.pem
```

### Verify Certificate
You can use OpenSSL to verify the certificate.

```bash
openssl verify -CAfile root_2023_ca.crt -untrusted intermediate.cert.pem nginx_certificate.pem
```

## Add certs to your trust store
Now we need to tell our server that it can trust certificates generated from the root CA, and therefore any intermediates it has signed. Before that, let's outline what certificates have been created:

| File                    | Description                                                                                        |
| ----------------------- | -------------------------------------------------------------------------------------------------- |
| root_2023_ca.crt        | The Root CA's certificate                                                                          |
| intermediate.cert.pem   | The intermediate CA's certificate                                                                  |
| pki_intermediate.csr    | The CSR used to sign the intermediate CA                                                           |
| nginx_certs.json        | A JSON file including all the certs generated by the issue command                                 |
| nginx_private_key.pem   | A short-lived private key for the `test.example.com` domain based on the `example-dot-com` role    |
| nginx_certificate.pem    | A short-lived certificate for the `test.example.com` domain based on the `example-dot-com` role   |
| nginx_ca_chain.pem      | A short-lived certificate chain, this contains the SSL/TLS Certificate and Certificate Authority (CA) Certificates, that enable the receiver to verify that the sender and all CAs are trustworthy |
| nginx_certificate_chain.pem | The cert and chain combined, used by NGINX                                                     |

### Ubuntu
```bash
sudo cp root_2023_ca.crt /usr/local/share/ca-certificates/
sudo update-ca-certificates
```

### CentOS/RHEL
```bash
yum install ca-certificates
update-ca-trust force-enable
cp root_2023_ca.crt /etc/pki/ca-trust/source/anchors/
update-ca-trust extract
```

## Generate certs and apply to NGINX
Now let's setup NGINX with our certs the generated certs, `nginx_private_key.pem` and `nginx_certificate_chain` in our case. First copy the certs to a sensible location

```bash
sudo mkdir /etc/nginx/keys
sudo cp nginx_private_key.pem nginx_certificate_chain.pem /etc/nginx/keys/
```

Now we need to update the NGINX config to enable TLS and use the new keys. You will need to add the following to your enabled site; this should be located here: `/etc/nginx/sites-enabled/default`. You can also look in the `default` file in this directory as an example.

```nginx
    listen 443 ssl default_server;
    ssl_certificate /etc/nginx/keys/nginx_certificate_chain.pem;
    ssl_certificate_key /etc/nginx/keys/nginx_private_key.pem;
```

Then restart NGINX.

```bash
sudo systemctl restart nginx
```

## Test Nginx
Since our cert is for `test.example.com`, we need to use this as a host header.

```bash
curl --resolve test.example.com:443:127.0.0.1 https://test.example.com/
```

# Use Vault agent to dynamically update NGINX
That is great but this will fail to work in 720 hours as the cert only lasts for that long, we need a way to automaticly rotate this from vault, wi will use Vault Agent for this.

## First let create a new approle
```bash
mkdir -p /tmp/certs
cat <<EOF > /tmp/certs/cert.policy
path "pki_int/issue*" {
  capabilities = ["create","update"]
}
path "auth/token/renew" {
  capabilities = ["update"]
}
path "auth/token/renew-self" {
  capabilities = ["update"]
}
EOF

vault policy write cert-policy /tmp/certs/cert.policy

vault auth enable approle
vault write auth/approle/role/cert-role token_policies="cert-policy" secret_id_ttl=24h token_ttl=5m token_max_ttl=4h
vault read -format=json auth/approle/role/cert-role/role-id > /tmp/certs/role.json
vault write -format=json -f auth/approle/role/cert-role/secret-id > /tmp/certs/secretid.json
export ROLE_ID="$(cat /tmp/certs/role.json | jq -r .data.role_id )" && echo $ROLE_ID | tee roleid > /tmp/certs/roleid
export SECRET_ID="$(cat /tmp/certs/secretid.json | jq -r .data.secret_id )" && echo $SECRET_ID |tee secretid > /tmp/certs/secretid
```

## Setup the vault-agent
```bash
cp vault-agent/* /tmp/certs/

export ROLE_ID="$(cat /tmp/certs/role.json | jq -r .data.role_id )" && echo $ROLE_ID | tee roleid > /tmp/certs/roleid
export SECRET_ID="$(cat /tmp/certs/secretid.json | jq -r .data.secret_id )" && echo $SECRET_ID |tee secretid > /tmp/certs/secretid
sudo vault agent -config=/tmp/certs/vault-agent.hcl
```